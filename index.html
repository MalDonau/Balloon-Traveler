<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Balloon Traveler</title>
<style>
  html, body { height: 100%; margin: 0; background:#000; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
  #ui { position: fixed; inset: 0 0 auto 0; display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; pointer-events:none; }
  #leftHUD, #rightHUD { display:flex; gap:14px; align-items:center; }
  .hud { background: rgba(0,0,0,.45); border: 2px solid #0ff; padding:6px 10px; border-radius: 10px; box-shadow: 0 0 10px #0ff8; pointer-events:auto; }
  button { cursor:pointer; background:#ff7a00; color:#000; border:2px solid #000; border-radius:10px; padding:6px 10px; font-weight:700; box-shadow:0 2px 0 #000; }
  button:active { transform: translateY(1px); box-shadow:0 1px 0 #000; }
  #touch { position: fixed; inset: auto 0 10px 0; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; padding: 0 10px; pointer-events: none; }
  #touch button { pointer-events:auto; opacity:.85; font-size:18px; }
  #touch .wide { grid-column: span 3; }
  #tip { position: fixed; left:50%; transform:translateX(-50%); bottom: 70px; background: rgba(255,0,255,.15); border:2px solid #ff00ff; padding:6px 10px; border-radius:10px; font-size:14px; }
  #warn { position: fixed; left:50%; transform:translateX(-50%); top: 10px; background: rgba(255,122,0,.15); border:2px solid #ff7a00; padding:6px 10px; border-radius:10px; font-size:12px; display:none; }
  canvas { display:block; width:100vw; height:100vh; }
  input[type=file]{ display:none; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- Sprite embebido (placeholder 1x1). Al exportar, se reemplaza por tu PNG en data URI -->
<img id="playerSprite" alt="player" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAs8B7z3q9i0AAAAASUVORK5CYII=" style="display:none" />

<div id="ui">
  <div id="leftHUD" class="hud">
    <div id="timer">‚è±Ô∏è 00.0s</div>
    <div id="best">üèÜ 0.0s</div>
  </div>
  <div id="rightHUD" class="hud">
    <button id="btnPause" title="Pause/Resume (P)">‚è∏Ô∏é/‚ñ∂Ô∏é</button>
    <button id="btnMute" title="Mute/Unmute (M)">üîà</button>
    <button id="btnRestart" title="Restart (R)">‚Üª</button>
    <button id="btnLoad" title="Cargar sprite PNG">üñºÔ∏è Sprite</button>
    <button id="btnExport" title="Exportar HTML con sprite embebido">üíæ Export</button>
    <input id="fileInput" type="file" accept="image/png,image/webp,image/jpeg" />
  </div>
</div>

<div id="touch">
  <button id="left" aria-label="Left">‚¨ÖÔ∏è</button>
  <button id="up" aria-label="Up">‚¨ÜÔ∏è</button>
  <button id="right" aria-label="Right">‚û°Ô∏è</button>
  <button id="down" class="wide" aria-label="Down">‚¨áÔ∏è</button>
</div>

<div id="warn">No sprite cargado ‚Äî usando placeholder. Arrastr√° tu PNG o toc√° üñºÔ∏è Sprite.</div>
<div id="tip">Flechas para moverte. Ascenso constante ‚Äî ¬°evit√° los cuervos! P: pausa ‚Ä¢ M: mute ‚Ä¢ R: reiniciar</div>

<script>
(()=>{
// ---------- Helpers ----------
const finiteOr = (v, fb=0)=> Number.isFinite(v) ? v : fb;
const warn = (msg)=>{ const el=document.getElementById('warn'); el.textContent=msg; el.style.display='block'; };
const hideWarn = ()=>{ document.getElementById('warn').style.display='none'; };

// ---------- Canvas ----------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
function resize(){ canvas.width = Math.floor((window.innerWidth||1) * DPR); canvas.height = Math.floor((window.innerHeight||1) * DPR); }
addEventListener('resize', resize); resize();

// ---------- Colors ----------
const CYAN='#00ffff', MAGENTA='#ff00ff', ORANGE='#ff7a00', BLACK='#000', WHITE='#fff';

// ---------- Sprite ----------
const playerImg = document.getElementById('playerSprite');
const SPRITE_SCALE = 0.6 * DPR; // m√°s grande para verlo claro
let spriteTime=0, useFallbackSprite=true;
function checkSprite(){
  const iw = playerImg.naturalWidth|0, ih = playerImg.naturalHeight|0;
  useFallbackSprite = !(iw>=16 && ih>=16);
  if(useFallbackSprite) warn('No sprite cargado ‚Äî usando placeholder. Arrastr√° tu PNG o toc√° üñºÔ∏è Sprite.');
  else hideWarn();
}
// cargar desde localStorage si ya se guard√≥
const storedSprite = localStorage.getItem('bt_sprite_datauri');
if(storedSprite) playerImg.src = storedSprite;
playerImg.onload = checkSprite; checkSprite();

// cargar sprite (bot√≥n / drag&drop / paste)
function setSpriteFromFile(file){
  const r=new FileReader();
  r.onload=()=>{ playerImg.src=r.result; }; // data URI
  r.readAsDataURL(file);
}
addEventListener('dragover', e=>{ e.preventDefault(); });
addEventListener('drop', e=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(f) setSpriteFromFile(f); });
const fileInput = document.getElementById('fileInput');
document.getElementById('btnLoad').onclick = ()=> fileInput.click();
fileInput.onchange = ()=>{ const f=fileInput.files?.[0]; if(f) setSpriteFromFile(f); };
addEventListener('paste', e=>{ const f=[...(e.clipboardData?.files||[])][0]; if(f) setSpriteFromFile(f); });
// persistir sprite en localStorage al cargar
playerImg.addEventListener('load', ()=>{
  try{ if(playerImg.src.startsWith('data:')) localStorage.setItem('bt_sprite_datauri', playerImg.src); }catch(e){}
});

// exportar HTML con el sprite embebido
document.getElementById('btnExport').onclick = ()=>{
  const dataUri = localStorage.getItem('bt_sprite_datauri') || playerImg.src;
  const html = buildExportHTML(dataUri);
  const blob = new Blob([html], {type:'text/html;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'balloon_traveler_single.html';
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);
};

// ---------- Input ----------
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
addEventListener('keydown', e=>{ if(e.code in keys){ keys[e.code]=true; e.preventDefault(); } if(e.code==='KeyP'){togglePause();} if(e.code==='KeyM'){toggleMute();} if(e.code==='KeyR'){restart();} });
addEventListener('keyup', e=>{ if(e.code in keys){ keys[e.code]=false; e.preventDefault(); } });
const touches = { left:false, right:false, up:false, down:false };
const bindHold = (el, prop)=>{ const on=()=>touches[prop]=true, off=()=>touches[prop]=false; el.addEventListener('pointerdown', e=>{e.preventDefault();on();el.setPointerCapture?.(e.pointerId);}); ['pointerup','pointercancel','pointerleave'].forEach(t=>el.addEventListener(t,off)); };
bindHold(document.getElementById('left'),'left'); bindHold(document.getElementById('right'),'right'); bindHold(document.getElementById('up'),'up'); bindHold(document.getElementById('down'),'down');

// ---------- Audio ----------
let audioReady=false, audioMuted=false; let ac, master;
function initAudio(){ if(audioReady) return; ac = new (window.AudioContext||window.webkitAudioContext)(); master = ac.createGain(); master.gain.value = 0.12; master.connect(ac.destination); audioReady=true; makeMusic(); }
function toggleMute(){ audioMuted=!audioMuted; if(master) master.gain.value = audioMuted?0:0.12; btnMute.textContent = audioMuted?'üîá':'üîà'; }
function makeMusic(){
  const bpm=128, beat=60/bpm, scale=[0,2,4,7,9];
  function note(t,semi,d=beat*0.45,type='sine',v=0.12){ const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value = 220*Math.pow(2, semi/12); g.gain.value=v; g.gain.setValueAtTime(v,t); g.gain.exponentialRampToValueAtTime(0.0001,t+d); o.connect(g); g.connect(master); o.start(t); o.stop(t+d); }
  function hat(t){ const n=ac.createBufferSource(), b=ac.createBuffer(1, 2205, ac.sampleRate), d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1 - i/d.length, 8); n.buffer=b; const g=ac.createGain(); g.gain.value=0.08; n.connect(g); g.connect(master); n.start(t); }
  function schedule(){ const base=ac.currentTime+0.05; for(let i=0;i<8;i++){ const t=base+i*beat*0.5; hat(t); if(i%2===0) hat(t+beat*0.25); const deg=scale[i%scale.length]; note(t,deg+12,beat*0.35,'triangle',0.10); if(i%4===0) note(t,deg,beat*0.5,'square',0.06); } }
  schedule(); setInterval(()=>{ if(audioMuted||ac?.state!=='running') return; schedule(); }, beat*1000*4);
}

// ---------- Game state ----------
const State={INTRO:0,PLAY:1,FALL:2,GAMEOVER:3}; let state=State.INTRO;
let startTime=performance.now(), elapsed=0, best=parseFloat(localStorage.getItem('bt_best')||'0')||0;
const timerEl=document.getElementById('timer'); const bestEl=document.getElementById('best');
bestEl.textContent='üèÜ '+best.toFixed(1)+'s';
const btnPause=document.getElementById('btnPause'); const btnMute=document.getElementById('btnMute'); const btnRestart=document.getElementById('btnRestart');
btnPause.onclick=()=>togglePause(); btnRestart.onclick=()=>restart(); btnMute.onclick=()=>toggleMute();
let paused=false; function togglePause(){ paused=!paused; btnPause.textContent=paused?'‚ñ∂Ô∏é':'‚è∏Ô∏é'; }

// ---------- World ----------
let cameraY=0; const clouds=[];
function startClouds(){ clouds.length=0; for(let i=0;i<30;i++) clouds.push(newCloud(true)); }
function newCloud(initial=false){ const w=canvas.width||1,h=canvas.height||1; return {x:Math.random()*w, y:(initial?Math.random()*h:(-50-Math.random()*200))+finiteOr(cameraY,0), r:20+Math.random()*80, speed:20+Math.random()*60, tint:Math.random()<0.5?CYAN:MAGENTA, alpha:0.15+Math.random()*0.25}; }

// ---------- Player ----------
function makePlayer(){ const x=canvas.width*0.4, y=canvas.height-60; return {x, y:y+finiteOr(cameraY,0), vx:0, vy:-30, speed:180, balloonRadius:18*DPR, grabbed:false, facing:1}; }
let player=makePlayer();

// ---------- Intro ----------
let introT=0; const cart={ x:()=>canvas.width*0.7, y:()=>canvas.height-60+finiteOr(cameraY,0) };

// ---------- Crows ----------
const crows=[];
function spawnCrow(){
  const w = canvas.width||1, h = canvas.height||1;
  const offset = 50; // spawn fully outside
  const cy = finiteOr(cameraY,0);
  const side = Math.floor(Math.random()*4); // 0=L,1=R,2=T,3=B
  let x,y;
  if(side===0){ // left edge
    x = -offset; y = Math.random()*h + cy;
  } else if(side===1){ // right edge
    x = w + offset; y = Math.random()*h + cy;
  } else if(side===2){ // top edge
    x = Math.random()*w; y = cy - offset;
  } else { // bottom edge
    x = Math.random()*w; y = cy + h + offset;
  }

  // Aim at player's current position at spawn time, then fly straight
  const px = player.x, py = player.y;
  const dx = px - x, dy = py - y;
  const len = Math.hypot(dx, dy) || 1;
  const speed = 90 + Math.random()*140 + difficulty*10; // keep same base speed
  const vx = (dx/len) * speed;
  const vy = (dy/len) * speed;

  // Small random start delay to de-sync entries
  const wait = 0.10 + Math.random()*0.45; // seconds

  crows.push({x,y,vx,vy,r:14*DPR,t:0,wait});
}
let nextCrow=0, difficulty=0; let explodeT=0;

// ---------- Utils ----------
function fmtTime(s){ return s.toFixed(1)+'s'; }
function clamp(v,min,max){ return v<min?min:v>max?max:v; }

// ---------- Loop ----------
let last=performance.now(); startClouds();
function restart(){ state=State.INTRO; player=makePlayer(); crows.length=0; nextCrow=0; difficulty=0; introT=0; explodeT=0; cameraY=0; startClouds(); startTime=performance.now(); elapsed=0; }
function update(dt){
  dt = finiteOr(dt, 0); cameraY = finiteOr(cameraY, 0);

  if(state===State.INTRO){
    introT+=dt; const targetX=cart.x()-50;
    player.vx=(targetX-player.x)*2; player.vx=clamp(player.vx,-220,220);
    player.x+=player.vx*dt; player.facing=Math.sign(player.vx)||1;
    cameraY-=10*dt;
    if(!player.grabbed && Math.abs(player.x-targetX)<6) player.grabbed=true;
    if(player.grabbed){ player.vy=-30; player.y+=player.vy*dt; cameraY+=player.vy*dt; }
    if(introT>3){
      // Transition to PLAY: ensure player starts safely inside bounds (to avoid instant border death)
      const minX=player.balloonRadius+10, maxX=canvas.width-player.balloonRadius-10;
      const minY=finiteOr(cameraY,0)+40, maxY=finiteOr(cameraY,0)+canvas.height-60;
      player.x = clamp(player.x, minX+1, maxX-1);
      player.y = clamp(player.y, minY+1, maxY-1);
      state=State.PLAY; initAudio();
    }
  }

  if(state===State.PLAY){
    elapsed=(performance.now()-startTime)/1000;
    difficulty=Math.min(12, elapsed*0.2);
    const left=keys.ArrowLeft||touches.left, right=keys.ArrowRight||touches.right, up=keys.ArrowUp||touches.up, down=keys.ArrowDown||touches.down;
    player.vx=0; player.vy=-30;
    if(left){player.vx-=player.speed; player.facing=-1;}
    if(right){player.vx+=player.speed; player.facing=1;}
    if(up){player.vy-=80;}
    if(down){player.vy+=120;}
    player.x+=player.vx*dt; player.y+=player.vy*dt;
    const minX=player.balloonRadius+10, maxX=canvas.width-player.balloonRadius-10, minY=finiteOr(cameraY,0)+40, maxY=finiteOr(cameraY,0)+canvas.height-60;
    player.x=clamp(player.x,minX,maxX); player.y=clamp(player.y,minY,maxY);
    // touching any screen margin is instant death
    if(player.x<=minX || player.x>=maxX || player.y<=minY || player.y>=maxY){ state=State.FALL; explodeT=0; }
    cameraY+=player.vy*dt;

    nextCrow-=dt*1000; const baseInterval=1100-difficulty*60;
    if(nextCrow<=0){ spawnCrow(); nextCrow=baseInterval*(0.6+Math.random()*0.8); }
    for(const c of crows){
      c.t += dt;
      if(c.wait>0){ c.wait -= dt; }
      else { c.x += c.vx*dt; c.y += c.vy*dt; }
    }
    for(let i=crows.length-1;i>=0;i--){
      const c=crows[i];
      const off = 60; // remove as soon as fully outside
      if(c.y < finiteOr(cameraY,0)-off || c.y > finiteOr(cameraY,0)+canvas.height+off || c.x < -off || c.x > canvas.width+off) {
        crows.splice(i,1);
      }
    }
    for(const c of crows){
      const dx=c.x-player.x, dy=c.y-(player.y-player.balloonRadius*2.2);
      const rr=(c.r+player.balloonRadius);
      if(dx*dx + dy*dy < rr*rr){ state=State.FALL; explodeT=0; break; }
    }
    timerEl.textContent='‚è±Ô∏è '+fmtTime(elapsed);
  }

  if(state===State.FALL){
    explodeT+=dt*1000; player.vy+=400*dt; player.y+=player.vy*dt; cameraY+=(player.vy*dt)*0.5;
    if(player.y>finiteOr(cameraY,0)+canvas.height+80){
      state=State.GAMEOVER; best=Math.max(best,elapsed); localStorage.setItem('bt_best',best); document.getElementById('best').textContent='üèÜ '+fmtTime(best);
    }
  }
}

function render(){
  const w = canvas.width||1, h = canvas.height||1; const cy = finiteOr(cameraY, 0);
  const y1 = finiteOr((cy % h) - h, 0), y2 = finiteOr((cy % h) + h, h);
  const g = ctx.createLinearGradient(0, y1, 0, y2);
  g.addColorStop(0,'#003b49'); g.addColorStop(0.5,CYAN); g.addColorStop(1,MAGENTA);
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);

  ctx.globalAlpha = 0.15; ctx.fillStyle = WHITE;
  for(let i=0;i<40;i++){ ctx.fillRect((i*83)%w, (Math.floor((i*97 + cy*0.05))%h), 2,2); }
  ctx.globalAlpha = 1;

  for(let i=0;i<clouds.length;i++){
    const c = clouds[i]; c.y += c.speed * 0.1; if(c.y - cy > h + 60) clouds[i] = newCloud(false);
    ctx.beginPath(); const puffs = 3 + (c.r/30|0);
    for(let k=0;k<puffs;k++){ const px=c.x + Math.cos(k*2*Math.PI/puffs)*c.r*0.9, py=c.y + Math.sin(k*2*Math.PI/puffs)*c.r*0.6; ctx.moveTo(px+c.r, py); ctx.arc(px, py, c.r*0.7, 0, Math.PI*2); }
    ctx.fillStyle = c.tint; ctx.globalAlpha = c.alpha; ctx.fill(); ctx.globalAlpha = 1;
  }

  if(state===State.INTRO){
    const cx=cart.x(), cyy=cart.y();
    ctx.fillStyle=ORANGE; ctx.fillRect(0,(canvas.height-30)+cy, w, 6);
    ctx.fillStyle=BLACK; ctx.fillRect(0,(canvas.height-24)+cy, w, 40);
    ctx.fillStyle=ORANGE; ctx.fillRect(cx-30, cyy-20, 60, 20);
    ctx.fillStyle=BLACK; ctx.fillRect(cx-22, cyy-26, 44, 6);
    ctx.beginPath(); ctx.arc(cx-18, cyy, 8*DPR, 0, Math.PI*2); ctx.arc(cx+18, cyy, 8*DPR, 0, Math.PI*2); ctx.fill();
    for(let i=0;i<6;i++){ const bx=cx-40+i*15, by=cyy-50-i*4; drawBalloon(bx,by,10*DPR,i%2?MAGENTA:CYAN); }
  }

  for(const c of crows) drawCrow(c);
  drawPlayer(player);
  if(state===State.GAMEOVER) drawGameOver();
}

function drawBalloon(x,y,r,color){
  ctx.strokeStyle=ORANGE; ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.moveTo(x,y+r); ctx.lineTo(x,y+r+30*DPR); ctx.stroke();
  ctx.fillStyle=color; ctx.beginPath(); ctx.ellipse(x,y,r*1.0,r*1.2,0,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=0.6; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(x-r*0.3,y-r*0.2,r*0.25,r*0.35,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
}
function drawCrow(c){
  ctx.save(); ctx.translate(c.x,c.y); const a=Math.atan2(c.vy,c.vx); ctx.rotate(a);
  ctx.fillStyle=BLACK; ctx.beginPath(); ctx.moveTo(-c.r*0.8,-c.r*0.6); ctx.quadraticCurveTo(c.r*0.2,-c.r*0.2,c.r*0.9,0); ctx.quadraticCurveTo(c.r*0.2,c.r*0.2,-c.r*0.8,c.r*0.6); ctx.closePath(); ctx.fill();
  ctx.fillStyle=ORANGE; ctx.beginPath(); ctx.moveTo(c.r*0.9,0); ctx.lineTo(c.r*1.2,-c.r*0.2); ctx.lineTo(c.r*1.2, c.r*0.2); ctx.closePath(); ctx.fill();
  const flap=Math.sin(c.t*10)*c.r*0.7; ctx.fillStyle=BLACK; ctx.beginPath(); ctx.moveTo(-c.r*0.3,0); ctx.lineTo(-c.r*0.3,-flap*0.6); ctx.lineTo(c.r*0.2,0); ctx.closePath(); ctx.fill();
  ctx.restore();
}
function drawPlayer(p){
  const bx=p.x, by=p.y - p.balloonRadius*2.2; drawBalloon(bx,by,p.balloonRadius,MAGENTA);
  const iw=playerImg.naturalWidth|0, ih=playerImg.naturalHeight|0; const hasSprite = (iw>=16 && ih>=16);
  const w=(hasSprite?iw:160)*SPRITE_SCALE, h=(hasSprite?ih:150)*SPRITE_SCALE;
  spriteTime+=1/60; const bob=Math.sin(spriteTime*6)*2*DPR; const lean=Math.max(-0.15, Math.min(0.15, (p.vx||0)/300));
  ctx.save(); ctx.translate(p.x, p.y + bob); ctx.rotate(lean); if(p.facing<0){ ctx.scale(-1,1);} const prev=ctx.imageSmoothingEnabled; ctx.imageSmoothingEnabled=false;
  if(hasSprite){ ctx.drawImage(playerImg, -w/2, -h*0.6, w, h); }
  else { // placeholder visible
    ctx.fillStyle = CYAN; ctx.fillRect(-6*DPR, -4*DPR, 12*DPR, 20*DPR);
    ctx.fillStyle = MAGENTA; ctx.fillRect(-8*DPR, 14*DPR, 4*DPR, 10*DPR); ctx.fillRect(4*DPR, 14*DPR, 4*DPR, 10*DPR);
    ctx.fillStyle = ORANGE; ctx.beginPath(); ctx.arc(0, -8*DPR, 6*DPR, 0, Math.PI*2); ctx.fill();
  }
  ctx.imageSmoothingEnabled=prev; ctx.restore();
}
function drawGameOver(){
  const w=canvas.width,h=canvas.height; const boxW=Math.min(420*DPR,w*0.9), boxH=180*DPR; const x=(w-boxW)/2, y=(h-boxH)/2;
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(x,y,boxW,boxH); ctx.strokeStyle=CYAN; ctx.lineWidth=4*DPR; ctx.strokeRect(x,y,boxW,boxH);
  ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font=(24*DPR)+'px system-ui, sans-serif'; ctx.fillText('Balloon popped! You fell...', w/2, y+42*DPR);
  ctx.fillStyle=ORANGE; ctx.font=(20*DPR)+'px system-ui, sans-serif'; ctx.fillText('Time: '+elapsed.toFixed(1)+'s   ‚Ä¢   Best: '+best.toFixed(1)+'s', w/2, y+80*DPR);
  ctx.fillStyle=MAGENTA; ctx.font=(18*DPR)+'px system-ui, sans-serif'; ctx.fillText('Press R to try again', w/2, y+120*DPR);
}
function loop(t){ let dt=(t-last)/1000; if(!Number.isFinite(dt)) dt=0; dt=Math.min(0.033, Math.max(0, dt)); last=t; if(!paused) update(dt); render(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
addEventListener('pointerdown', ()=>{ initAudio(); }, { once:true });

// ---------- Export helper ----------
function buildExportHTML(dataUri){
  const srcDoc = document.documentElement.outerHTML;
  return srcDoc.replace(/(<img id="playerSprite"[^>]*src=")[^"]+(")/i, `$1${dataUri}$2`);
}

// ---------- Tests ----------
;(function tests(){
  console.assert(finiteOr(5, 1) === 5, 'finiteOr should pass finite');
  console.assert(finiteOr(NaN, 7) === 7, 'finiteOr should fallback on NaN');
  const cy = finiteOr(NaN, 0), h = canvas.height||1; const y1 = finiteOr((cy%h)-h, 0); const y2 = finiteOr((cy%h)+h, h);
  console.assert(Number.isFinite(y1) && Number.isFinite(y2), 'gradient coordinates must be finite');
  // Crow spawn outside screen + aiming tests
  (function(){
    for(let k=0;k<10;k++){
      spawnCrow(); const c = crows[crows.length-1];
      const out = (c.x < -49) || (c.x > canvas.width+49) || (c.y < finiteOr(cameraY,0)-49) || (c.y > finiteOr(cameraY,0)+canvas.height+49);
      console.assert(out, 'crow should spawn outside');
      // Velocity should point toward player at spawn
      const vlen = Math.hypot(c.vx,c.vy)||1; const nvx=c.vx/vlen, nvy=c.vy/vlen;
      const dx = (player.x - c.x), dy = (player.y - c.y); const dlen=Math.hypot(dx,dy)||1; const ndx=dx/dlen, ndy=dy/dlen;
      const dot = nvx*ndx + nvy*ndy; console.assert(dot>0.98, 'crow velocity should aim at player (~same direction)');
      console.assert(c.wait>=0.09 && c.wait<=0.56, 'wait delay within expected range');
    }
  })();
})();

})();
</script>
</body>
</html>
